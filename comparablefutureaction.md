<h1>CompletableFuture in action</h1>

After thoroughly exploring <code>CompletableFuture</code> API in Java 8</a> we are prepared to write a simplistic web crawler. We solved similar problem already using <a href="http://nurkiewicz.blogspot.no/2013/02/executorcompletionservice-in-practice.html"><code>ExecutorCompletionService</code></a>, <a href="http://nurkiewicz.blogspot.no/2013/02/advanced-listenablefuture-capabilities.html">Guava <code>ListenableFuture</code></a> and <a href="http://nurkiewicz.blogspot.no/2013/03/futures-in-akka-with-scala.html">Scala/Akka</a>. I choose the same problem so that it's easy to compare approaches and implementation techniques.

First we shall define a simple, blocking method to download the contents of a single URL:

<div>
<div id="highlighter_599194" class="syntaxhighlighter  java">
<div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">private</code> <code class="java plain">String downloadSite(</code><code class="java keyword">final</code> <code class="java plain">String site) {</code></div><div class="line number2 index1 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">try</code> <code class="java plain">{</code></div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">log.debug(</code><code class="java string">"Downloading {}"</code><code class="java plain">, site);</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">final</code> <code class="java plain">String res = IOUtils.toString(</code><code class="java keyword">new</code> <code class="java plain">URL(</code><code class="java string">"<a href="http://">http://</a>"</code> <code class="java plain">+ site), UTF_8);</code></div><div class="line number5 index4 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">log.debug(</code><code class="java string">"Done {}"</code><code class="java plain">, site);</code></div><div class="line number6 index5 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">return</code> <code class="java plain">res;</code></div><div class="line number7 index6 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">} </code><code class="java keyword">catch</code> <code class="java plain">(IOException e) {</code></div><div class="line number8 index7 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">throw</code> <code class="java plain">Throwables.propagate(e);</code></div><div class="line number9 index8 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">}</code></div><div class="line number10 index9 alt1"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>

Nothing fancy. This method will be later invoked for different sites inside thread pool. Another method parses the <code>String</code> into an XML <code>Document</code> (let me leave out the implementation, no one wants to look at it):

<div><div id="highlighter_65711" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">private</code> <code class="java plain">Document parse(String xml)&nbsp; </code><code class="java comments">//...</code></div></div></td></tr></tbody></table></div></div>

Finally the core of our algorithm, function computing <i>relevance</i> of each website taking <code>Document</code> as input. Just as above we don't care about the implementation, only the signature is important:

<div><div id="highlighter_782591" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">private</code> <code class="java plain">CompletableFuture&lt;Double&gt; calculateRelevance(Document doc) </code><code class="java comments">//...</code></div></div></td></tr></tbody></table></div></div>

Let's put all the pieces together. Having a list of websites our crawler shall start downloading the contents of each web site asynchronously and concurrently. Then each downloaded HTML string will be parsed to XML <code>Document</code> and later <i>relevance</i> will be computed. As a last step we take all computed <i>relevance</i> metrics and find the biggest one. This sounds pretty straightforward to the moment when you realize that both downloading content and computing <i>relevance</i> is asynchronous (returns <code>CompletableFuture</code>) and we definitely don't want to block or busy wait. Here is the first piece:


<div><div id="highlighter_57245" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java plain">ExecutorService executor = Executors.newFixedThreadPool(</code><code class="java value">4</code><code class="java plain">);</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="java plain">List&lt;String&gt; topSites = Arrays.asList(</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java string">"www.google.com"</code><code class="java plain">, </code><code class="java string">"www.youtube.com"</code><code class="java plain">, </code><code class="java string">"www.yahoo.com"</code><code class="java plain">, </code><code class="java string">"www.msn.com"</code></div><div class="line number5 index4 alt2"><code class="java plain">);</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="java plain">List&lt;CompletableFuture&lt;Double&gt;&gt; relevanceFutures = topSites.stream().</code></div><div class="line number8 index7 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">map(site -&gt; CompletableFuture.supplyAsync(() -&gt; downloadSite(site), executor)).</code></div><div class="line number9 index8 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">map(contentFuture -&gt; contentFuture.thenApply(</code><code class="java keyword">this</code><code class="java plain">::parse)).</code></div><div class="line number10 index9 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">map(docFuture -&gt; docFuture.thenCompose(</code><code class="java keyword">this</code><code class="java plain">::calculateRelevance)).</code></div><div class="line number11 index10 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">collect(Collectors.&lt;CompletableFuture&lt;Double&gt;&gt;toList());</code></div></div></td></tr></tbody></table></div></div>

There is actually <b>a lot</b> going on here. Defining thread pool and sites to crawl is obvious. But there is this chained expression computing <code>relevanceFutures</code>. The sequence of <code>map()</code> and <code>collect()</code> in the end is quite descriptive. Starting from a list of web sites we transform each site (<code>String</code>) into <code>CompletableFuture&lt;String&gt;</code> by submitting asynchronous task (<code>downloadSite()</code>) into thread pool.

So we have a list of <code>CompletableFuture&lt;String&gt;</code>. We continue transforming it, this time applying <code>parse()</code> method on each of them. Remember that <code>thenApply()</code> will invoke supplied lambda when underlying future completes and returns <code>CompletableFuture&lt;Document&gt;</code> immediately. Third and last transformation step composes each <code>CompletableFuture&lt;Document&gt;</code> in the input list with <code>calculateRelevance()</code>. Note that <code>calculateRelevance()</code> returns <code>CompletableFuture&lt;Double&gt;</code> instead of <code>Double</code>, thus we use <code>thenCompose()</code> rather than <code>thenApply()</code>. After that many stages we finally <code>collect()</code> a list of <code>CompletableFuture&lt;Double&gt;</code>.

Now we would like to run some computations on <i>all</i> results. We have a list of futures and we would like to know when all of them (last one) complete. Of course we can register completion callback on each future and use <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html"><code>CountDownLatch</code></a> to block until all callbacks are invoked. I am too lazy for that, let us utilize existing <a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html#allOf(java.util.concurrent.CompletableFuture...)"><code>CompletableFuture.allOf()</code></a>. Unfortunately it has two minor drawbacks - takes vararg instead of <code>Collection</code> and doesn't return a future of aggregated results but <code>Void</code> instead. By aggregated results I mean: if we provide <code>List&lt;CompletableFuture&lt;Double&gt;&gt;</code> such method should return <code>CompletableFuture&lt;List&lt;Double&gt;&gt;</code>, not <code>CompletableFuture&lt;Void&gt;</code>! Luckily it's easy to fix with a bit of glue code:<br>

<div><div id="highlighter_86479" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">private</code> <code class="java keyword">static</code> <code class="java plain">&lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; sequence(List&lt;CompletableFuture&lt;T&gt;&gt; futures) {</code></div><div class="line number2 index1 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">CompletableFuture&lt;Void&gt; allDoneFuture =</code></div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">CompletableFuture.allOf(futures.toArray(</code><code class="java keyword">new</code> <code class="java plain">CompletableFuture[futures.size()]));</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">return</code> <code class="java plain">allDoneFuture.thenApply(v -&gt;</code></div><div class="line number5 index4 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">futures.stream().</code></div><div class="line number6 index5 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">map(future -&gt; future.join()).</code></div><div class="line number7 index6 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">collect(Collectors.&lt;T&gt;toList())</code></div><div class="line number8 index7 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">);</code></div><div class="line number9 index8 alt2"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>

Watch carefully <code>sequence()</code> argument and return types. The implementation is surprisingly simple, the trick is to use existing <code>allOf()</code> but when <code>allDoneFuture</code> completes (which means all underlying futures are done), simply iterate over all futures and <code>join()</code> (blocking wait) on each. However this call is guaranteed not to block because by now all futures completed! Equipped with such utility method we can finally complete our task:<br>

<div><div id="highlighter_110746" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java plain">CompletableFuture&lt;List&lt;Double&gt;&gt; allDone = sequence(relevanceFutures);</code></div><div class="line number2 index1 alt1"><code class="java plain">CompletableFuture&lt;OptionalDouble&gt; maxRelevance = allDone.thenApply(relevances -&gt;</code></div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">relevances.stream().</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">mapToDouble(Double::valueOf).</code></div><div class="line number5 index4 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">max()</code></div><div class="line number6 index5 alt1"><code class="java plain">);</code></div></div></td></tr></tbody></table></div></div>

This one is easy - when <code>allDone</code> completes, apply our function that counts maximal relevance in whole set. <code>maxRelevance</code> is still a future. By the time your JVM reaches this line, probably none of the websites are yet downloaded. But we encapsulated business logic on top of futures, stacking them in an event-driven manner. Code remains readable (version without lambda and with ordinary <code>Future</code>s would be at least twice as long) but avoids blocking main thread. Of course <code>allDone</code> can as well be an intermediate step, we can further transform it, not really having the result yet.<br>

<h2>Shortcomings</h2>

<code>CompletableFuture</code> in Java 8 is a huge step forward. From tiny, thin abstraction over asynchronous task to full-blown, functional, feature rich utility. However after few days of playing with it I found few minor disadvantages:<br>

<ul>
<li>
<a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html#allOf(java.util.concurrent.CompletableFuture...)"><code>CompletableFuture.allOf()</code></a> returning <code>CompletableFuture&lt;Void&gt;</code> discussed earlier. I think it's fair to say that if I pass a collection of futures and want to wait for all of them, I would also like to extract the results when they arrive easily. It's even worse with <a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html#anyOf(java.util.concurrent.CompletableFuture...)"><code>CompletableFuture.anyOf()</code></a>. If I am waiting for <i>any</i> of the futures to complete, I can't imagine passing futures of different types, say <code>CompletableFuture&lt;Car&gt;</code> and <code>CompletableFuture&lt;Restaurant&gt;</code>. If I don't care which one completes first, how am I suppose to handle return type? Typically you will pass a collection of homogeneous futures (e.g. <code>CompletableFuture&lt;Car&gt;</code>) and then <code>anyOf()</code> can simply return future of that type (instead of <code>CompletableFuture&lt;Void&gt;</code> again).<br><br>
</li>
<li>
Mixing <i>settable</i> and <i>listenable</i> abstractions. In Guava there is <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/ListenableFuture.html"><code>ListenableFuture</code></a> and <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/SettableFuture.html"><code>SettableFuture</code></a> extending it. <code>ListenableFuture</code> allows registering callbacks while <code>SettableFuture</code> adds possibility to set value of the future (resolve it) from arbitrary thread and context. <code>CompletableFuture</code> is equivalent to <code>SettableFuture</code> but there is no limited version equivalent to <code>ListenableFuture</code>. Why is it a problem? If API returns <code>CompletableFuture</code> and then two threads wait for it to complete (nothing wrong with that), one of these threads can resolve this future and wake up other thread, while it's only the API implementation that should do it. But when API tries to resolve the future later, call to <code>complete()</code> is ignored. It can lead to really nasty bugs which are avoided in Guava by separating these two responsibilities.<br><br>
</li>

<li>
<code>CompletableFuture</code> is ignored in JDK. <code>ExecutorService</code> was not retrofitted to return <code>CompletableFuture</code>. Literally <code>CompletableFuture</code> is not referenced anywhere in JDK. It's a really useful class, backward compatible with <code>Future</code>, but not really promoted in standard library.<br><br>
</li>

<li>
Bloated API (?) Fifty methods in total, most in three variants. Splitting <i>settable</i> and <i>listenable</i> (see above) would help. Also some methods like <code>runAfterBoth()</code> or <code>runAfterEither()</code> IMHO do not really belong to any <code>CompletableFuture</code>. Is there a difference between <code>fast.runAfterBoth(predictable, ...)</code> and <code>predictable.runAfterBoth(fast, ...)</code>? No, but API favours one or the other. Actually I believe <code>runAfterBoth(fast, predictable, ...)</code> much better expresses my intention.<br><br>
</li>

<li>
<code>CompletableFuture.getNow(T)</code></a> should take <code>Supplier&lt;T&gt;</code> instead of raw reference. In the example below <code>expensiveAlternative()</code> is always code, irrespective to whether future finished or not:

<div><div id="highlighter_448807" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java plain">future.getNow(expensiveAlternative());</code></div></div></td></tr></tbody></table></div></div>

However we can easily tweak this behaviour (I know, there is a small race condition here, but the original <code>getNow()</code> works this way as well):<br><br>

<div><div id="highlighter_76855" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">public</code> <code class="java keyword">static</code> <code class="java plain">&lt;T&gt; T getNow(</code></div><div class="line number2 index1 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">CompletableFuture&lt;T&gt; future, </code></div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">Supplier&lt;T&gt; valueIfAbsent) </code><code class="java keyword">throws</code> <code class="java plain">ExecutionException, InterruptedException {</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">if</code> <code class="java plain">(future.isDone()) {</code></div><div class="line number5 index4 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">return</code> <code class="java plain">future.get();</code></div><div class="line number6 index5 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">} </code><code class="java keyword">else</code> <code class="java plain">{</code></div><div class="line number7 index6 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">return</code> <code class="java plain">valueIfAbsent.get();</code></div><div class="line number8 index7 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">}</code></div><div class="line number9 index8 alt2"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>

With this utility method we can avoid calling <code>expensiveAlternative()</code> when it's not needed:<br><br>

<div><div id="highlighter_282065" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java plain">getNow(future, () -&gt; expensiveAlternative());</code></div><div class="line number2 index1 alt1"><code class="java comments">//or:</code></div><div class="line number3 index2 alt2"><code class="java plain">getNow(future, </code><code class="java keyword">this</code><code class="java plain">::expensiveAlternative);</code></div></div></td></tr></tbody></table></div></div>

</li>

</ul>

In overall <code>CompletableFuture</code> is a wonderful new tool in our JDK belt. Minor API issues and sometimes too verbose syntax due to limited type inference shouldn't stop you from using it. At least it's a solid foundation for better abstractions and more robust code.



