<h1>Java Future basics </h1>

Hereby I am starting a series of articles about <i>future</i> concept in programming languages (also known as <a href="http://en.wikipedia.org/wiki/Futures_and_promises"><i>promises</i> or <i>delays</i></a>) with a working title: <a href="http://www.imdb.com/title/tt0088763/"><i>Back to the Future</i></a>. <i>Futures</i> are very important abstraction, even more these day than ever due to growing demand for asynchronous, event-driven, parallel and scalable systems. In the first article we'll discover most basic <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html"><code>java.util.concurrent.Future&lt;T&gt;</code></a> interface. Later on we will jump into other frameworks, libraries or even languages. <code>Future&lt;T&gt;</code> is pretty limited, but essential to understand, <i>ekhm</i>, future parts.<br>

In a single-threaded application when you call a method it returns only when the computations are done (<a href="http://commons.apache.org/io/apidocs/org/apache/commons/io/IOUtils.html#toString(java.io.InputStream,%20java.nio.charset.Charset)"><code>IOUtils.toString()</code></a> comes from <a href="http://commons.apache.org/io/">Apache Commons IO</a>):<br>

<div><div id="highlighter_46379" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">public</code> <code class="java plain">String downloadContents(URL url) </code><code class="java keyword">throws</code> <code class="java plain">IOException {</code></div><div class="line number2 index1 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">try</code><code class="java plain">(InputStream input = url.openStream()) {</code></div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">return</code> <code class="java plain">IOUtils.toString(input, StandardCharsets.UTF_8);</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">}</code></div><div class="line number5 index4 alt2"><code class="java plain">}</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="java comments">//...</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="java keyword">final</code> <code class="java plain">String contents = downloadContents(</code><code class="java keyword">new</code> <code class="java plain">URL(</code><code class="java string">"<a href="http://www.example.com">http://www.example.com</a>"</code><code class="java plain">));</code></div></div></td></tr></tbody></table></div></div>

<code>downloadContents()</code> looks harmless<sup>1</sup>, but it can take even arbitrary long time to complete. Moreover in order to reduce latency you might want to do other, independent processing in the meantime, while waiting for results. In the old days you would start a new <code>Thread</code> and somehow wait for results (shared memory, locks, dreadful <code>wait()</code>/<code>notify()</code> pair, etc.) With <code>Future&lt;T&gt;</code> it's much more pleasant:<br>

<div><div id="highlighter_477514" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">public</code> <code class="java keyword">static</code> <code class="java plain">Future&lt;String&gt; startDownloading(URL url) {</code></div><div class="line number2 index1 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java comments">//...</code></div><div class="line number3 index2 alt2"><code class="java plain">}</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="java keyword">final</code> <code class="java plain">Future&lt;String&gt; contentsFuture = startDownloading(</code><code class="java keyword">new</code> <code class="java plain">URL(</code><code class="java string">"<a href="http://www.example.com">http://www.example.com</a>"</code><code class="java plain">));</code></div><div class="line number6 index5 alt1"><code class="java comments">//other computation</code></div><div class="line number7 index6 alt2"><code class="java keyword">final</code> <code class="java plain">String contents = contentsFuture.get();</code></div></div></td></tr></tbody></table></div></div>

We will implement <code>startDownloading()</code> soon. For now it's important that you understand the principles. <code>startDownloading()</code> does <b>not</b> block, waiting for external website. Instead it returns immediately, returning a lightweight <code>Future&lt;String&gt;</code> object. This object is a <i>promise</i> that <code>String</code> will be available in the future. Don't know when, but keep this reference and once it's there, you'll be able to retrieve it using <code>Future.get()</code>. In other words <code>Future</code> is a proxy or a wrapper around an object that is not yet there. Once the asynchronous computation is done, you can extract it. So what API does <code>Future</code> provide?<br>

<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get()"><code>Future.get()</code></a> is the most important method. It blocks and waits until promised result is available (<i>resolved</i>). So if we really need that <code>String</code>, just call <code>get()</code> and wait. There is an <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get(long,%20java.util.concurrent.TimeUnit)">overloaded version</a> that accepts timeout so you won't wait forever if something goes wild. <code>TimeoutException</code> is thrown if waiting for too long.<br>

In some use cases you might want to peek on the <code>Future</code> and continue if result is not yet available. This is possible with <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#isDone()"><code>isDone()</code></a>. Imagine a situation where your user waits for some asynchronous computation and you'd like to let him know that we are still waiting and do some computation in the meantime:<br>

<div><div id="highlighter_526570" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">final</code> <code class="java plain">Future&lt;String&gt; contentsFuture = startDownloading(</code><code class="java keyword">new</code> <code class="java plain">URL(</code><code class="java string">"<a href="http://www.example.com">http://www.example.com</a>"</code><code class="java plain">));</code></div><div class="line number2 index1 alt1"><code class="java keyword">while</code> <code class="java plain">(!contentsFuture.isDone()) {</code></div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">askUserToWait();</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">doSomeComputationInTheMeantime();</code></div><div class="line number5 index4 alt2"><code class="java plain">}</code></div><div class="line number6 index5 alt1"><code class="java plain">contentsFuture.get();</code></div></div></td></tr></tbody></table></div></div>

The last call to <code>contentsFuture.get()</code> is guaranteed to return immediately and not block because <code>Future.isDone()</code> returned <code>true</code>. If you follow the pattern above make sure you are not busy waiting, calling <code>isDone()</code> millions of time per second.<br>

Cancelling futures is the last aspect we have not covered yet. Imagine you started some asynchronous job and you can only wait for it given amount of time. If it's not there after, say, 2 seconds, we give up and either propagate error or work around it. However if you are a good citizen, you should somehow tell this future object: I no longer need you, forget about it. You save processing resources by not running obsolete tasks. The syntax is simple:<br>

<div><div id="highlighter_65461" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java plain">contentsFuture.cancel(</code><code class="java keyword">true</code><code class="java plain">);&nbsp;&nbsp;&nbsp; </code><code class="java comments">//meh...</code></div></div></td></tr></tbody></table></div></div>

We all love cryptic, boolean parameters, aren't we? Cancelling comes in two flavours. By passing <code>false</code> to <code>mayInterruptIfRunning</code> parameter we only cancel tasks that didn't yet started, when the <code>Future</code> represents results of computation that did not even began. But if our <code>Callable.call()</code> is already in the middle, we let it finish. However if we pass <code>true</code>, <code>Future.cancel()</code> will be more aggressive, trying to interrupt already running jobs as well. How? Think about all these methods that throw infamous <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/InterruptedException.html"><code>InterruptedException</code></a>, namely <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#sleep(long)"><code>Thread.sleep()</code></a>,  <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait()"><code>Object.wait()</code></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Condition.html#await()"><code>Condition.await()</code></a>,  and many others (including <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get()"><code>Future.get()</code></a>). If you are blocking on any of such methods and someone decided to cancel your <code>Callable</code>, they will actually throw <code>InterruptedException</code>, signalling that someone is trying to interrupt currently running task.<br>

<hr/>

So we now understand what <code>Future&lt;T&gt;</code> is - a place-holder for something, that you will get in the future. It's like keys to a car that was not yet manufactured. But how do you actually obtain an instance of <code>Future&lt;T&gt;</code> in your application? Two most common sources are thread pools and asynchronous methods (backed by thread pools for you). Thus our <code>startDownloading()</code> method can be rewritten to:<br>

<div><div id="highlighter_301152" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java keyword">private</code> <code class="java keyword">final</code> <code class="java plain">ExecutorService pool = Executors.newFixedThreadPool(</code><code class="java value">10</code><code class="java plain">);</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="java keyword">public</code> <code class="java plain">Future&lt;String&gt; startDownloading(</code><code class="java keyword">final</code> <code class="java plain">URL url) </code><code class="java keyword">throws</code> <code class="java plain">IOException {</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">return</code> <code class="java plain">pool.submit(</code><code class="java keyword">new</code> <code class="java plain">Callable&lt;String&gt;() {</code></div><div class="line number5 index4 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java color1">@Override</code></div><div class="line number6 index5 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">public</code> <code class="java plain">String call() </code><code class="java keyword">throws</code> <code class="java plain">Exception {</code></div><div class="line number7 index6 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">try</code> <code class="java plain">(InputStream input = url.openStream()) {</code></div><div class="line number8 index7 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">return</code> <code class="java plain">IOUtils.toString(input, StandardCharsets.UTF_8);</code></div><div class="line number9 index8 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">}</code></div><div class="line number10 index9 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">}</code></div><div class="line number11 index10 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">});</code></div><div class="line number12 index11 alt1"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>

A lot of syntax boilerplate, but the basic idea is simple: wrap long-running computations in <code>Callable&lt;String&gt;</code> and <code>submit()</code> them to a thread pool of 10 threads. Submitting returns some implementation of <code>Future&lt;String&gt;</code>, most likely somehow linked to your task and thread pool. Obviously your task is not executed immediately. Instead it is placed in a queue which is later (maybe even much later) polled by thread from a pool. Now it should be clear what these two flavours of <code>cancel()</code> mean - you can always cancel task that still resides in that queue. But cancelling already running task is a bit more complex.<br>

Another place where you can meet <code>Future</code> is Spring and EJB. For example in Spring framework you can simply <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/scheduling.html#scheduling-annotation-support-async">annotate your method with <code>@Async</code></a>:<br>

<div><div id="highlighter_885813" class="syntaxhighlighter  java"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="java color1">@Async</code></div><div class="line number2 index1 alt1"><code class="java keyword">public</code> <code class="java plain">Future&lt;String&gt; startDownloading(</code><code class="java keyword">final</code> <code class="java plain">URL url) </code><code class="java keyword">throws</code> <code class="java plain">IOException {</code></div><div class="line number3 index2 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">try</code> <code class="java plain">(InputStream input = url.openStream()) {</code></div><div class="line number4 index3 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java keyword">return</code> <code class="java keyword">new</code> <code class="java plain">AsyncResult&lt;&gt;(</code></div><div class="line number5 index4 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">IOUtils.toString(input, StandardCharsets.UTF_8)</code></div><div class="line number6 index5 alt1"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">);</code></div><div class="line number7 index6 alt2"><code class="java spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="java plain">}</code></div><div class="line number8 index7 alt1"><code class="java plain">}</code></div></div></td></tr></tbody></table></div></div>

Notice that we simply wrap our result in <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/scheduling/annotation/AsyncResult.html"><code>AsyncResult</code></a> implementing <code>Future</code>. But the method itself does not deal with thread pool or asynchronous processing. Later on Spring will proxy all calls to <code>startDownloading()</code> and run them in a thread pool. The exact same feature is available through <a href="http://docs.oracle.com/javaee/6/tutorial/doc/gkkqg.html"><code>@Asynchronous</code> annotation in EJB</a>.<br>

So we learned a lot about <code>java.util.concurrent.Future</code>. Now it's time to admit - this interface is quite limited, especially when compared to other languages. More on that later.<br>



